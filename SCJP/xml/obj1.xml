<?xml version="1.0" encoding="UTF-8"?>

<obj xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
 xsi:noNamespaceSchemaLocation="resources/pytania.xsd"
 >
    <pyt>
        <nr>1</nr>
        <tresc><![CDATA[Which method declarations, when inserted independently at the indicated position, will not cause the program to fail during compilation?
        
        public class Test {
            public long sum(long a, long b) {return a + b;}
            // insert new method here.
        }]]></tresc>
        <level>1</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>2</liczba_poprawnych>
        <odp>public int sum(int a, int b) {return a + b;}</odp>
        <odp>public int sum(long a, long b) {return a + b;}</odp>
        <odp>abstract int sum();</odp>
        <odp>private static long sum(long a, long b) {return a + b;}</odp>
        <odp>public long sum(long a, int b) {return  a + b;}</odp>
        <poprawne>1,5</poprawne>
    </pyt>
    <pyt>
        <nr>2</nr>
        <tresc><![CDATA[sWhat will happen when you compile and run the following code?
        
        pubilc class MyClass 
        {
            private static int x = getValue();
            private static int y = 5;
            
            private static int getValue() {
                return y;
            }
            
            public static void main(String[] args) {
                System.out.println(x);
            }
        }]]>
        </tresc>
        <level>1</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error about access restriction of private variable of MyClass</odp>
        <odp>Compiler error about forward referencing of the getValue() method</odp>
        <odp>Prints 0</odp>
        <odp>Compiler error about forward referencing of the y static field</odp>
        <odp>Prints 1</odp>
        <poprawne>3</poprawne>
    </pyt>
    <pyt>
        <nr>3</nr>
        <tresc>What happens when you try to compile and run the following program?
        
        1. class Mystery 
        2. {
        3.     String s;
        4.     public static void main(String[] args) 
        5.     {
        6.             Mystery m = new Mystery();
        7.             m.go();
        8.     }
        9.     void Mystery()
        10.    {
        11.            s = "Constructor";
        12.    }
        13.
        14.    void go()
        15.    {
        16.           System.out.println(s);
        17.    }
        18.}
        </tresc>
        <level>1</level>        
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>The code does not compile.</odp>
        <odp>The code runs but nothing appears in the standard output.</odp>
        <odp>The code runs and "Constructor" appears in the standard output.</odp>
        <odp>The code runs and writes "null" in the standard output.</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>4</nr>
        <tresc>Which of the following are legal identifiers?</tresc>
        <level>1</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>3</liczba_poprawnych>
        <odp>!done</odp>
        <odp>publicprotected</odp>
        <odp>hello-world</odp>
        <odp>$34</odp>
        <odp>_we45$</odp>
        <poprawne>2,4,5</poprawne>
    </pyt>
    <pyt>
        <nr>5</nr>
        <tresc>Which of the following import statements are legal?</tresc>
        <level>1</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>2</liczba_poprawnych>
        <odp>import java.lang;</odp>
        <odp>static import java.lang.Math;</odp>
        <odp>import java.lang.Math;</odp>
        <odp>import static java.lang.Math.*;</odp>
        <odp>static import java.lang.Math.*;</odp>
        <poprawne>3,4</poprawne>
    </pyt>
    <pyt>
        <nr>6</nr>
        <tresc>What will happen when you attempt to compile and run the following class?
        
        class Base 
        {
            Base(int i)
                {
                    System.out.println("Base");
                }
        }
        class Derived extends Base 
        {
            public static void main(String[] args)
            {
                Derived d = new Derived();
            }
            
            void Derived() 
            {
                System.out.println("Derived");
            }
        }
        </tresc>
        <level>1</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiles fine and prints "Derived" at runtime</odp>
        <odp>Compiler error</odp>
        <odp>Compiles fine but no output is produced</odp>
        <odp>Compiles fine and prints "Base" at runtime</odp>
        <poprawne>2</poprawne>
    </pyt>
    <pyt>
        <nr>7</nr>
        <tresc>Given the following code for the Demo class, what would be the result of calling the showName() method with an argument of 0 immediatly after creating an instance of Demo?
        
        public class Demo 
        {
            private String userNames[];
            public Demo()
            {
                userNames = new String[10];
            }
            public void showName(int n)
            {
                System.out.println("Name is " + userNames[n]);
        	}
        
	        public String getName(int n)
	        {
	        	return(userNames[n]);
	       	}
        }
        </tresc>
        <level>1</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Prints "Name is null".</odp>
        <odp>A NullPointerException would be thrown.</odp>
        <odp>An ArrayIndexOutOfBoundsException would be thrown.</odp>
        <odp>Prints "Name is ".</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>8</nr>
        <tresc>Which is the correct method for getting the value of a String property 'name' according to the JavaBean naming standards?</tresc>
        <level>1</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>public String getname(){}</odp>
        <odp>public String getName(String name){}</odp>
        <odp>public String getName(){}</odp>
        <odp>public String get_name(){}</odp>
        <poprawne>3</poprawne>
    </pyt>
    <pyt>
        <nr>9</nr>
        <tresc>What will be the value of y when the following code is executed?
        
        class A {
            int increment(int x) {
                return x + 10;
            }
            
            long increment(int x) {
                return x + 20;
            }
        }
        
        class B extends A {
            public static void main(String[] args) {
                B b = new B();
                int y = b.increment(12);
            }
        }
        </tresc>
        <level>1</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>12</odp>
        <odp>22</odp>
        <odp>32</odp>
        <odp>This code causes compile-time error.</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>10</nr>
        <tresc>What is the result of compiling and running the given code?
        
        class A {
            int b=10;
            private A(){
                this.b=7;
            }
            int f(){
                return b;
            }
        }
        
        class B extends A{
            int b;
        }
        
        class Test{
            public static void main(String[] args){
                A a = new B();
                System.out.println(a.f());
            }
        }</tresc>
        <level>1</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Does not compile</odp>
        <odp>Prints 0</odp>
        <odp>Prints 10</odp>
        <odp>Prints 7</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>11</nr>
        <tresc>class ABC{
            static int[] arr1;
            int[] arr2 = new int[10];
            static float[] arr3 = {};
            
            void f() {
                double[] arr4;
            }
        }
        
        Which of the following are true about the above code?
        </tresc>
        <level>1</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>3</liczba_poprawnych>
        <odp>arr1 is initialized to null</odp>
        <odp>arr4 is initialized to null</odp>
        <odp>arr3.length==0</odp>
        <odp>arr2.length==9</odp>
        <odp>arr2[0]==0</odp>
        <poprawne>1,3,5</poprawne>
    </pyt>    
    <pyt>
        <nr>12</nr>
        <tresc>What will be the result of compiling and running the following code?
        
        class A {
            int i;
            A(){}
        }
        class B extends A {
            B(short i) {
                this.i = i; System.out.println("short");
            }
            B(float j) {
				i = (int)j;
				System.out.print("float");
			}
        }
        public class Test extends B {
            Test() {
				super(4);
			}
			public static void main(String[] args) {
				System.out.print(new Test().i); //line 1
            }
        }
            </tresc>
        <level>2</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Code does not compile</odp>
        <odp>Code throws Exception at runtime</odp>
        <odp>Prints "float4"</odp>
        <odp>Prints "short4"</odp>
        <odp>Prints "0"</odp>
        <poprawne>3</poprawne>
    </pyt>
    <pyt>
        <nr>13</nr>
        <tresc>Which of the following are legal identifiers for variable names?</tresc>
        <level>2</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>instanceOf</odp>
        <odp>3_$int</odp>
        <odp>-int</odp>
        <odp>!byte</odp>
        <odp>volatile</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>14</nr>        
        <tresc>What is the result of compiling and running the following program?
        
        enum Fish {
            GOLDFISH, ANGELFISH, GUPPY;
        }
        
        public class EnumTest2{
            public static void main(String[] args){
                Fish f = Fish.valueOf("GUPPY");
                if (f==Fish.GUPPY)
                    System.out.println("Are equal");
                if (f.equals(Fish.GUPPY))
                    System.out.println("Are equal");
             }
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error</odp>
        <odp>Prints "Are equal" twice</odp>
        <odp>Prints "Are equal" once</odp>
        <odp>Prints nothing</odp>
        <poprawne>2</poprawne>
    </pyt>
    <pyt>
        <nr>15</nr>
        <tresc>What will be the result of compiling and running the following code?
        
        class TestInner {
			int i=10; //1
			TestInner() {
				System.out.print("Outer");   //2
			}
			static class MyInner {
				MyInner(){
					System.out.println(i);    //3
				}
			}
			public static void main(String[] args) {  // 4
				new TestInner.MyInner();   //5
			}
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compilation fails at line 3</odp>
        <odp>Compilation fails at line 5</odp>
        <odp>Prints "Outer10"</odp>
        <odp>None of the above</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>16</nr>
        <tresc>What is the result of compiling and running the following code fragment?
        
        String[][][] arr = {
	        { {}, null},
	        { { "1", "2"}, {"1", null, "3"}},
	        {},
	        { {"1", null} }
        };
        System.out.println(arr.length + arr[1][2].length);
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>The program will terminate with an ArrayIndexOutOfBoundsException</odp>
        <odp>The program will terminate with a NullPointerException</odp>
        <odp>4 will be writen to standard output</odp>
        <odp>6 will be writen to standard output</odp>
        <odp>7 will be writen to standard output</odp>
        <poprawne>1</poprawne>
    </pyt>
        <pyt>
        <nr>17</nr>
        <tresc>What will be the result of compiling and running the following code?
        
        class MyOuter {
			private class MyInner {
				float f() {return 1.2;}
            }
        
			MyInner getInner() {
				return new MyInner();
			}
        }
        
        class Test {
            public static void main(String[] args) {
                MyOuter outer = new MyOuter();
                System.out.println(outer.getInner.f());
            }
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Prints 1.2</odp>
        <odp>Compiler error only because: Cannot access the functions of a private inner class</odp>
        <odp>Compiler error only because: Cannot access the object of a private inner class</odp>
        <odp>None of the above</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>18</nr>
        <tresc>What is the result of compiling and executing the following code?
        
        class Vararg2 {
            public static void main(String[] args) {
                Integer i[] = {2,3,4};
                test(i);
                test();
            }
            public static void test(int ... s) {
                for (int i : s) 
                    System.out.printf("%d \n", i);
            }
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Does not compile because test(Integer[]) cannot be applied to test(int?)</odp>
        <odp>Does not compile because test() cannot be applied to test(int?)</odp>
        <odp>Prints 2,3,4</odp>
        <odp>None of the above</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>19</nr>
        <tresc>Which of the given options are legal return types for the method callMe() in the class Test?
        
        interface X {}
        class AA{}
        class A extends AA implements X {}
        class B extends A {}
        class C extends B {}
        class SuperTest {
            public A callMe() { return new A();}
        }
        class Test extends SuperTest {
            public ??? callMe() {return new C();}
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>2</liczba_poprawnych>
        <odp>X</odp>
        <odp>AA</odp>
        <odp>B</odp>
        <odp>C</odp>
        <poprawne>3,4</poprawne>
    </pyt>
    <pyt>
        <nr>20</nr>
        <tresc>What will happen when you attempt to compile and run the following code?
        
        public final class Test {
            class Inner {
                void test()
                {
                    if (Test.this.bool);
                    {
                        myMethod();
                    }
                }
             }
             private boolean bool = false;
             
             public void myMethod() 
             {
                 System.out.println("myMethod");
             }
             
             public Test() 
             {    
                 (new Inner()).test();
             }
             
             public static void main(String[] args) 
             {
                  new Test();
             }
        }   
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Prints "myMethod"</odp>
        <odp>Program produces no output but terminates correctly</odp>
        <odp>Program does not terminate</odp>
        <odp>The program will not compile</odp>
        <poprawne>2</poprawne>
    </pyt>
    <pyt>
        <nr>21</nr>
        <tresc>Given the following enum definition
        enum Grade {A,B,C,D}
        Which of the following will compile?
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Grade grade = Grade.A;</odp>
        <odp>Grade grade = new Grade(Grade.A);</odp>
        <odp>Grade sportsGrade extends Grade {A1, B1};</odp>
        <odp>Both A and B</odp>
        <odp>Both B and C</odp>
        <poprawne>1</poprawne>
    </pyt>
    <pyt>
        <nr>22</nr>
        <tresc>What will happen when you compile and run the following code?
        
        public class MyClass {
            static int x;
            public static void main(String[] args)
            {
                x = 5;
                MyClass m1 = new MyClass();
                MyClass m2 = new MyClass();
                MyClass m3 = new MyClass();
                m1.x = 10;
                m2.x = 20;
                m3.x = 30;
                System.out.println(m1.x);
                System.out.println(m2.x);
                System.out.println(m3.x);
            }
        }
        </tresc>
        <level>2</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error</odp>
        <odp>Prints 10, 20, 30</odp>
        <odp>Prints 30, 30, 30</odp>
        <odp>None of the these</odp>
        <poprawne>3</poprawne>
    </pyt>
    <pyt>
        <nr>23</nr>
        <tresc>Which of the following methods can be overridden by subclasses?</tresc>
        <level>2</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>2</liczba_poprawnych>
        <odp>private methods</odp>
        <odp>static methods</odp>
        <odp>abstract methods</odp>
        <odp>synchronized methods</odp>
        <odp>final methods</odp>
        <poprawne>3,4</poprawne>
    </pyt>
    <pyt>
        <nr>24</nr>
        <tresc><![CDATA[What will be result of attempting to compile and run the following code?
        
        class Test {
	        public static void main(String[] args) {
		        int[] i = {1,2,3,4,5};
		        float[] j = new float[5];
		        for (int k=0; k<j.length();k++) {
		        	i[k] = (char)j[k];
		        	System.out.println(i[k]);
		        }
	        }
        }]]>
        </tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error - char cannot be assigned to int</odp>
        <odp>Compiler error - Array j is not initialized</odp>
        <odp>ArrayIndexOutOfBoundsException at runtime</odp>
        <odp>Prints 0 five times</odp>
        <odp>Prints 0.0 five times</odp>
        <odp>None of the above</odp>
        <poprawne>6</poprawne>
    </pyt>    
    <pyt>
        <nr>25</nr>
        <tresc><![CDATA[Given the following enum definition
        
        package pack1;
        public class EnumClass {
        	public enum MyEnum {A, B, C};
        }
        
        Which of the following code excerpts must be (independently) inserted above the following class definition so that it compiles and runs without errors?
        
        class Test {
        	public static void main(String[] args) {
        		for (MyEnum o : MyEnum.values())
        			System.out.println(o);
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>4</liczba_poprawnych>
        <odp>import static pack1.EnumClass.MyEnum;</odp>
        <odp>import pack1.EnumClass.MyEnum;</odp>
        <odp>import pack1.EnumClass.*;</odp>
        <odp>import static pack1.EnumClass.MyEnum.*;</odp>
        <odp>import pack1.EnumClass.MyEnum.*;</odp>
        <odp>import static pack1.EnumClass.*;</odp>
        <poprawne>1,2,3,6</poprawne>
    </pyt>
    <pyt>
        <nr>26</nr>
        <tresc><![CDATA[What will be the result of compiling and running the following code?
        
        abstract class a {
			final void f() {}
			abstract synchronized void g();
			static void h(){}
			a(){}
			public static void main(String[] args) {
				a obj;
			}
        }]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error - Abstract classes cannot have final methods</odp>
        <odp>Compiler error - Abstract classes cannot have constructors</odp>
        <odp>Compiler error - Abstract classes cannot have static methods</odp>
        <odp>Compiler error - Abstract methods cannot be synchronized</odp>
        <odp>Compiler error - Abstract classes cannot be instantined</odp>
        <odp>The code compiles and runs without errors</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>27</nr>
        <tresc><![CDATA[What will be the result of compiling and running the following code?
        
        import java.util.*;
        public class Test {
			public abstract class InnerTest {
				abstract void f();
			}
			 
			public static void main(String[] args) 
			{
				Test t = new Test();
				Test.InnerTest test = t.new InnerTest()
					{
          			public void f()
         				{
							System.out.println("Inner f");
         				}
         			};
         	}
         }
         	]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Does not compile</odp>
        <odp>Prints "Inner f"</odp>
        <odp>Throws an exception at runtime</odp>
        <odp>Compiles and runs, but produces no output</odp>
        <odp>None of the above</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>28</nr>
        <tresc><![CDATA[What will be the result of attempting to compile and run the following program?
        
        class TestInner {
			private static int i = 10;
			private static void f() {
				System.out.println(i);
			}
			TestInner() {
				System.out.print("Outer");
			}
			static class MyInner {
				MyInner() {
					System.out.print("Inner");
				}
				void g() {
					f();
				} 
			}
			public static void main(String[] args) {
				new TestInner.MyInner();
			}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>7</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Prints "OuterInner10"</odp>
        <odp>Prints "Outer10"</odp>
        <odp>Prints "OuterInner"</odp>
        <odp>Prints "Inner10"</odp>
        <odp>Prints "Inner"</odp>
        <odp>Code does not compile</odp>
        <odp>None of the above</odp>
        <poprawne>5</poprawne>
    </pyt>
    <pyt>
        <nr>29</nr>
        <tresc><![CDATA[What is the result of compiling and executing the following code?
        
        class MyBoolean
        {
        	Boolean bool[]  = new Boolean[5];
        	public static void main(String[] args)
        	{
        		new MyBoolean().myMethod();
        	}
        	public void myMethod() {
        		if (bool[1] == true)
        		{
        			System.out.println("It's true");
        		}
        		else
        		{
        			System.out.println("It's false");
        		}
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Prints "It's true"</odp>
        <odp>Prints "It's false"</odp>
        <odp>Compile time error</odp>
        <odp>Exception</odp>
        <odp>None of the above</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>30</nr>
        <tresc><![CDATA[Which of the following statements is/are true about compiling and running the following code?
        
        class Test
        {
        	final Object obj;
        	Test()
        	{
        		obj = null; // 1
        		System.out.println(obj instanceof Object); //2
        		Integer i = new Integer("1"); //3
        		obj = i;    //4
        	}
        	public static void main(String[] args) 
        	{
        		Test test = new Test();
        		System.out.println(test.obj);
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>The program compiles correctly and prints "false" and null</odp>
        <odp>The program will compile correctly if line 1 is removed</odp>
        <odp>The program will compile correctly if line 2 is removed</odp>
        <odp>The program will compile correctly if line 3 is removed</odp>
        <odp>The program will compile correctly if line 4 is removed</odp>
        <odp>None of the above</odp>
        <poprawne>5</poprawne>
    </pyt>
    <pyt>
        <nr>31</nr>
        <tresc><![CDATA[What is the result of compiling and running the following code?
        
        abstract class AbstractTest {
        	static int i;
        	abstract Object test();
        	AbstractTest() {
        		System.out.println("A");
        	}
        }
        
        class Test extends AbstractTest {
        	Integer test() {
        		return i;
        	}
        	public static void main(String[] args){
        		Test t = new Test();
        		System.out.println(t.test());
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error</odp>
        <odp>Prints "A" followed by 0</odp>
        <odp>Prints 0</odp>
        <odp>None of the above</odp>
        <poprawne>2</poprawne>
    </pyt>
    <pyt>
        <nr>32</nr>
        <tresc><![CDATA[What is the result of attempting to compile and run the following code?
        
        abstract class SuperTest 
        {
        	static int i = 10;
        }
        class Test extends SuperTest implements Inter
        {
        	final static int i;
        	static {i = 9;}
        	void f() {System.out.println("i is "+i); }
        	public static void main(String[] args)
        	{
        		Inter t = new Test();
        		t.f();
        	}
        }
        
        interface Inter 
        {
        	int i = 1;
        	void f();
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Code does not compile because you cannot extend a class and implement an interface at the same time</odp>
        <odp>Code does not compile because SuperTest does not contain any abstract method</odp>
        <odp>Code does not compile because a final static variable cannot be initialized in a static block</odp>
        <odp>Code compiles and prints 9</odp>
        <odp>Code compiles and prints 1</odp>
        <odp>None of the above</odp>
        <poprawne>6</poprawne>
    </pyt>
    <pyt>
        <nr>33</nr>
        <tresc><![CDATA[import java.util.*;
        public class Test {
        void f()
        	{
        		System.out.println("Outer");
        	}
        public class InnerTest
       	{
       		InnerTest() { System.out.println("Inner constructor"); }
       		void f() {
       			System.out.println("Inner f");
       		}
       	}
       	public static void main(String[] args) 
       	{
       		Test t = new Test();
       		Test.InnerTest test = t.new InnerTest()
       		{
       			public void f()
       			{
       				t.f();
       				System.out.println("Sub Inner f");
       			}
       		};
       		test.f();
       	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Code does not compile</odp>
        <odp>Prints "Inner Constructor", "Outer" and "Sub Inner f"</odp>
        <odp>Prints "Outer" and "Sub Inner f"</odp>
        <odp>Prints "Outer", "Inner f" and "Sub Inner f"</odp>
        <odp>Prints "Inner Constructor", "Outer", "Inner f" and "Sub Inner f"</odp>
        <odp>None of the above</odp>
        <poprawne>1</poprawne>
    </pyt><pyt>
        <nr>34</nr>
        <tresc><![CDATA[What is the result of compiling and running the following code?
        
        interface Inter {}
        
        class First implements Inter {
        	public Inter method1() {
        	System.out.println("super");
        	return new First();
        	}
        }
        
        class Second extends First {
        	public First method1() {
        	System.out.println("sub");
        	return new Second();
        	}
        }
        
        public class CovariantTest2 {
        	public static void main(String[] args) { 
        		First first = new Second();
        		Inter first1 = first.method1();
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Does not compile</odp>
        <odp>ClassCastException is thrown</odp>
        <odp>Prints "super"</odp>
        <odp>Prints "sub"</odp>
        <poprawne>4</poprawne>
    </pyt>
    <pyt>
        <nr>35</nr>
        <tresc><![CDATA[What is the result of compiling and running the following code?
        
        public class EnumTest3 {
        	enum Employee{
        		MANAGER,
        		CLERK,
        		SECRETARY
        	}
        	public static void main(String[] args){
        		new EnumTest3(Employee.CLERK);
        	}
        	EnumTest3(Employee emp) {
        		switch(emp) {
        		case MANAGER:
        			System.out.println("Manager");
        		case CLERK:
        			System.out.println("Clerk");
        		case SECRETARY:
        			System.out.println("Secretary");
        		}
        	}
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>4</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>Compiler error: case statement must use enum name as prefix for constants</odp>
        <odp>Compiler error: missing semicolon in enum syntax</odp>
        <odp>Prints "Clerk" followed by "Secretary"</odp>
        <odp>Prints "Clerk"</odp>
        <poprawne>3</poprawne>
    </pyt>
    <pyt>
        <nr>36</nr>
        <tresc><![CDATA[In the given piece of code, which members of class A can be accessed within class B?
        
        package pack1;
        
        public class A {
        	int i;
        	public static float f;
        	static int j;
        	public void f() {}
        	public static void g() {}
        }
        
        package pack2;
        
		import static pack1.A.*;
		
		public class B{ // Accessing A's members}
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>5</liczba_odpowiedzi>
        <liczba_poprawnych>2</liczba_poprawnych>
        <odp>i</odp>
        <odp>f</odp>
        <odp>j</odp>
        <odp>f()</odp>
        <odp>g()</odp>
        <poprawne>2,5</poprawne>
    </pyt>
    <pyt>
        <nr>37</nr>
        <tresc><![CDATA[What will be the result of compiling the following program?
        
        interface myInterface {
        	abstract void f1();		// line 1
        	protected int f2();		// line 2
        	static double f3();		// line 3
        }
        ]]></tresc>
        <level>3</level>
        <liczba_odpowiedzi>6</liczba_odpowiedzi>
        <liczba_poprawnych>1</liczba_poprawnych>
        <odp>The code will compile correctly</odp>
        <odp>The code will compile correctly if line 1 is removed</odp>
        <odp>The code will compile correctly if line 2 is removed</odp>
        <odp>The code will compile correctly if line 3 is removed</odp>
        <odp>The code will compile correctly if lines 2 and 3 are removed</odp>
        <odp>The code will compile correctly if lines 1 and 3 are removed</odp>
        <poprawne>5</poprawne>
    </pyt>
</obj>
